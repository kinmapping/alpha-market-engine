# システムアーキテクチャ

自動売買 bot と管理 API を分離し、docker-compose で 24/7 安定稼働させる構成の設計メモ。FastAPI の再起動やデプロイで bot を止めないことを最優先とする。


## 全体アーキの最小構成

### 言語

- Python(第一候補): Python はライブラリと検証の豊富さ最強
- Node.js(軽量リアルタイム寄り): WebSocket 多様・高頻度のイベント駆動に強い。

### 実行基盤
Docker / docker-compose

### 取引所接続
- ccxt（複数取引所RESTの共通化）
- 各取引所のWSクライアント（板/約定/ティッカーのリアルタイム取得）

### イベント駆動の骨格
- asyncio（Python） or RxJS（Node）
- 「WSで受信 → 戦略評価 → 注文 → 結果をWS/RESTで確認」のループ

## イベントレイヤーごとの技術スタック

### Market Data (データ取得)
- WebSocket：板/約定/ティッカーを常時購読
- REST：補助（口座残高、過去OHLCV、注文履歴）
- データ保存
  - TimescaleDB(PostgreSQL拡張) / InfluxDB（時系列向け）
  - まずは PostgreSQL単体でもOK

- OHLCV生成
  - pandas / polars（高速）

### Strategy / Signal（戦略）
- テクニカル指標：ta-lib / pandas-ta
- 戦略フレームワーク（必要なら）
  - lightweightに自作（おすすめ）
  - or backtrader / freqtrade を参考にする
- AI/ML系（後で追加）
  - scikit-learn（まずこれ）
  - PyTorch（深層やるなら）
  - ただし 最初からAI前提にしない方が勝率が上がる
    → まずルールベースを動かしてデータ/パイプラインを固めるのが最短。

### Execution（注文・リスク管理）
- 注文管理
  - 注文IDと状態遷移を持つステートマシン
  - 部分約定・取消・リトライを考慮

- リスク管理
  - 最大ポジション/最大損失/連敗停止/スプレッドフィルタ
  - ここは “戦略より大事” まである

### Backtest / Simulation（検証）

- バックテスト
  - pandasベース自作 or backtrader

- イベント駆動シミュレータ
  - 実運用と同じループ構造で過去WS相当を流す
  → “本番との差分バグ”が激減する

### Ops（運用）

- 監視
  - Prometheus + Grafana（本格）
  - まずは ログ + Slack/Discord通知が現実的

- ログ
  - structlog / loguru（Python）
  - 取引判断・注文・約定・例外を全部JSONログへ

- シークレット管理
  - dotenv（開発）
  - 本番は AWS Secrets Manager / GCP Secret Manager

- CI/CD
  - GitHub Actions

- 本番実行環境
  - 小さく始めるなら VPS/EC2
  - 安定重視なら ECS/Fargate

## 全体構成（想定ディレクトリ）
```bash
─│┬┴ ┼├ ┤└ ┘┌ ┐
docker-compose.yml
.env.example
bot/
  ├─ main.py          # エントリーポイント
  ├─ exchange.py      # GMO REST/WS クライアント
  ├─ strategy.py      # 売買ロジック
  ├─ logger.py        # 構造化ログ/DB 出力
  └─ requirements.txt
api/
  ├─ app.py           # FastAPI インスタンス
  ├─ routes.py        # ルーティングと依存解決
  ├─ schemas.py       # Pydantic スキーマ
  └─requirements.txt
shared/
  ├─ config.py        # 設定/環境変数の読み取り
  └─ db.py            # DB 接続ユーティリティ
db/                # PostgreSQL データディレクトリ（Docker ボリューム想定）
```

## コンポーネントと役割
- bot コンテナ：WS 購読、シグナル判定、REST 発注、約定処理、DB へのログ書き込み
- FastAPI コンテナ：`/health` `/bot/status` `/logs` を提供し、DB から状態・ログを参照
- PostgreSQL：発注・約定ログと bot 状態を永続化。bot と API から読み書きされる

## 通信
- bot ↔ GMO：Public WS（ticker/orderbooks/trades）、Private REST（order, cancel, assets）
- bot → PostgreSQL：トランザクションログ、bot 状態
- FastAPI → PostgreSQL：状態照会、ログ取得
- FastAPI → 外部：HTTP エンドポイント（bot への直接 RPC は行わない）

## データフロー
1. bot が WS で ticker/板/約定を購読
2. strategy がシグナルを生成（例：移動平均交差）
3. REST で発注/取消し、レスポンスとシグナルをログに保存
4. 約定イベントを WS で受信し、DB に反映
5. FastAPI が DB を参照して状態・ログを返す

## 信頼性・運用メモ
- WS/REST の失敗はリトライ＋バックオフ、再購読を標準化
- bot と API はプロセス・コンテナを分離し、相互のクラッシュ影響を避ける
- ログは stdout と DB の両方に出し、docker logs と API 参照の両面で確認できるようにする
